<script type="text/javascript">
        var gk_isXlsx = false;
        var gk_xlsxFileLookup = {};
        var gk_fileData = {};
        function filledCell(cell) {
          return cell !== '' && cell != null;
        }
        function loadFileData(filename) {
        if (gk_isXlsx && gk_xlsxFileLookup[filename]) {
            try {
                var workbook = XLSX.read(gk_fileData[filename], { type: 'base64' });
                var firstSheetName = workbook.SheetNames[0];
                var worksheet = workbook.Sheets[firstSheetName];

                // Convert sheet to JSON to filter blank rows
                var jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1, blankrows: false, defval: '' });
                // Filter out blank rows (rows where all cells are empty, null, or undefined)
                var filteredData = jsonData.filter(row => row.some(filledCell));

                // Heuristic to find the header row by ignoring rows with fewer filled cells than the next row
                var headerRowIndex = filteredData.findIndex((row, index) =>
                  row.filter(filledCell).length >= filteredData[index + 1]?.filter(filledCell).length
                );
                // Fallback
                if (headerRowIndex === -1 || headerRowIndex > 25) {
                  headerRowIndex = 0;
                }

                // Convert filtered JSON back to CSV
                var csv = XLSX.utils.aoa_to_sheet(filteredData.slice(headerRowIndex)); // Create a new sheet from filtered array of arrays
                csv = XLSX.utils.sheet_to_csv(csv, { header: 1 });
                return csv;
            } catch (e) {
                console.error(e);
                return "";
            }
        }
        return gk_fileData[filename] || "";
        }
        </script><!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Virtual Guitar</title>
    <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
    <style>
        body { margin: 0; font-family: 'Arial', sans-serif; overflow: hidden; }
        #container { position: relative; width: 100vw; height: 100vh; }
        #canvas { display: block; }
        .vibrating { animation: vibrate 0.05s alternate infinite; }
        @keyframes vibrate {
            0% { transform: translateY(0); }
            100% { transform: translateY(0.015); }
        }
        .tooltip:hover::after {
            content: attr(data-tooltip);
            @apply absolute bg-gray-800 text-white text-sm px-2 py-1 rounded;
            z-index: 20;
            bottom: -2rem;
            left: 50%;
            transform: translateX(-50%);
        }
        .string-hover { color: #FFFF00 !important; }
        .fret-hover { emissive: 0xFFFF00 !important; }
        #chord-popup, #fret-popup, #loading { display: none; }
        .draggable { cursor: move; }
        .note-marker { position: absolute; width: 12px; height: 12px; border-radius: 50%; background: rgba(255, 85, 85, 0.8); z-index: 5; }
        .chord-marker { position: absolute; width: 12px; height: 12px; border-radius: 50%; background: rgba(85, 255, 85, 0.8); z-index: 6; }
        #fret-popup { position: absolute; background: rgba(0, 0, 0, 0.8); color: white; padding: 4px 8px; border-radius: 4px; z-index: 30; font-size: 12px; }
        #loading { @apply fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50; }
        .fretboard-grid { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; }
        .fretboard-grid div { border: 1px solid rgba(255, 255, 255, 0.2); }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
</head>
<body class="bg-gradient-to-br from-gray-900 to-blue-900">
    <div id="container">
        <canvas id="canvas" aria-label="3D Guitar Fretboard"></canvas>
        <div class="absolute top-4 left-4 bg-black bg-opacity-75 p-4 rounded-lg shadow-xl z-10 text-white md:w-80">
            <h3 class="text-xl font-bold mb-2">Virtual Guitar</h3>
            <div class="flex flex-col gap-2">
                <select id="chord-picker" class="bg-gray-700 text-white px-4 py-2 rounded-lg" aria-label="Select a chord">
                    <option value="">Select Chord</option>
                </select>
                <div id="chord-buttons" class="flex flex-wrap gap-2"></div>
            </div>
            <div class="mt-4 flex flex-col gap-2">
                <button id="toggle-mouse" class="bg-cyan-500 text-white px-4 py-2 rounded-lg hover:bg-cyan-600" data-tooltip="Toggle Camera/Fretboard Mode" aria-label="Toggle mouse mode">Camera Mode</button>
                <button id="strum" class="bg-yellow-500 text-black px-4 py-2 rounded-lg hover:bg-yellow-600" data-tooltip="Strum current chord or frets" aria-label="Strum chord or frets">Strum</button>
                <button id="strum-marked" class="bg-yellow-600 text-black px-4 py-2 rounded-lg hover:bg-yellow-700" data-tooltip="Strum marked notes" aria-label="Strum marked notes">Strum Marked Notes</button>
                <button id="save-chord" class="bg-purple-500 text-white px-4 py-2 rounded-lg hover:bg-purple-600" data-tooltip="Save current fretboard as chord" aria-label="Save chord">Save Chord</button>
                <button id="lock-chord" class="bg-blue-500 text-white px-4 py-2 rounded-lg hover:bg-blue-600" data-tooltip="Lock current fretboard for recall" aria-label="Lock chord">Lock Chord</button>
                <select id="recall-chord" class="bg-gray-700 text-white px-4 py-2 rounded-lg" aria-label="Recall locked chord">
                    <option value="">Recall Locked Chord</option>
                </select>
                <button id="replay-notes" class="bg-orange-500 text-white px-4 py-2 rounded-lg hover:bg-orange-600" data-tooltip="Replay marked notes" aria-label="Replay marked notes">Replay Notes</button>
                <button id="clear-notes" class="bg-red-500 text-white px-4 py-2 rounded-lg hover:bg-red-600" data-tooltip="Clear marked notes" aria-label="Clear marked notes">Clear Notes</button>
                <label class="flex items-center"><input type="checkbox" id="record" class="mr-2" aria-label="Record toggle"> Record</label>
                <div id="playback-buttons" class="flex flex-wrap gap-2"></div>
                <button id="save-all" class="bg-green-500 text-white px-4 py-2 rounded-lg hover:bg-green-600" data-tooltip="Download chords & recordings" aria-label="Save all data">Save All</button>
                <input type="file" id="load-all" class="hidden" accept=".json" aria-label="Load data file">
                <button onclick="document.getElementById('load-all').click()" class="bg-green-500 text-white px-4 py-2 rounded-lg hover:bg-green-600" data-tooltip="Upload chords & recordings" aria-label="Load all data">Load All</button>
                <button id="edit-chords" class="bg-gray-500 text-white px-4 py-2 rounded-lg hover:bg-gray-600" data-tooltip="Edit/move chords" aria-label="Edit chords">Edit Chords</button>
            </div>
        </div>
        <div class="absolute bottom-4 left-4 right-4 bg-black bg-opacity-75 p-4 rounded-lg shadow-xl z-10 text-white md:w-3/4 md:right-auto">
            <h4 class="text-md font-semibold mb-2">Fretboard (Click to mark notes)</h4>
            <div id="strings" class="flex justify-around mt-2 relative"></div>
        </div>
        <div class="absolute bottom-4 right-4 bg-black bg-opacity-75 p-4 rounded-lg shadow-xl z-10 text-white md:w-24">
            <h4 class="text-md font-semibold mb-2">Piano</h4>
            <div id="piano-keys" class="flex flex-col gap-1"></div>
        </div>
        <div class="absolute top-4 right-4 bg-black bg-opacity-75 p-4 rounded-lg shadow-xl z-10 text-white md:w-40">
            <p>Mouse: <span id="mouse-mode">Rotate/Zoom</span></p>
            <p>Click Guitar: Play/Mark Note</p>
            <p>Roll Over Strings: Strum</p>
            <p>Space/Strum: Play Chord/Frets</p>
            <p>Esc: Clear Chord/Frets</p>
        </div>
        <div id="chord-popup" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-20 hidden">
            <div class="bg-gray-800 p-6 rounded-lg text-white w-full max-w-md">
                <h3 class="text-lg font-bold mb-4">Edit Chords</h3>
                <div id="chord-list" class="flex flex-col gap-2"></div>
                <button id="close-popup" class="bg-red-600 text-white px-4 py-2 rounded-lg mt-4 hover:bg-red-700" aria-label="Close chord editor">Close</button>
            </div>
        </div>
        <div id="fret-popup" aria-live="polite"></div>
        <div id="loading">
            <div class="text-white text-lg">Loading...</div>
        </div>
    </div>

    <script>
        // Error handling wrapper
        window.onerror = function(msg, url, lineNo, columnNo, error) {
            console.error('Script error:', msg, 'at', url, 'line', lineNo, 'column', columnNo, error);
            alert('An error occurred. Please check the console for details or try refreshing the page.');
            return false;
        };

        // Web Audio API
        let audioContext;
        function initAudio() {
            try {
                if (!audioContext) {
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                }
            } catch (e) {
                console.error('AudioContext initialization failed:', e);
                alert('Audio not supported in this browser. Some features may not work.');
            }
        }

        function playNote(frequency, duration = 1, type = 'sawtooth') {
            if (!audioContext) return;
            try {
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                oscillator.frequency.value = frequency;
                oscillator.type = type;
                gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + duration);
                oscillator.start(audioContext.currentTime);
                oscillator.stop(audioContext.currentTime + duration);
                return { freq: frequency, dur: duration, time: Date.now() };
            } catch (e) {
                console.error('Error playing note:', e);
            }
        }

        // Note names
        const noteNames = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
        function getNoteName(frequency) {
            const midiNote = 12 * Math.log2(frequency / 440) + 69;
            const noteIndex = Math.round(midiNote) % 12;
            const octave = Math.floor(midiNote / 12) - 1;
            return `${noteNames[noteIndex]}${octave}`;
        }

        // Tuning and chords
        const tuning = [329.63, 246.94, 196.00, 146.83, 110.00, 82.41]; // E4 to E2
        const notes = ['E4', 'B3', 'G3', 'D3', 'A2', 'E2'];
        const chords = {
            'C': [0, 1, 0, 2, 3, 0], 'Cm': [0, 1, 0, 1, 3, 0], 'C7': [0, 1, 0, 2, 3, 0],
            'D': [-1, 0, 0, 2, 3, 2], 'Dm': [-1, 0, 0, 2, 1, 0], 'D7': [-1, 0, 0, 2, 3, 0],
        };
        let currentChord = null;
        const currentFrets = [0, 0, 0, 0, 0, 0];
        const lockedChords = {};
        const markedNotes = [];
        let noteMarkers = [];
        let chordMarkers = [];
        let noteLabels = [];

        // Three.js setup
        let scene, camera, renderer, controls, guitar, strings = [], frets = [], cursor;
        let isFretboardMode = false;
        function init3D() {
            try {
                scene = new THREE.Scene();
                scene.background = new THREE.Color(0x1a1a1a);

                camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                camera.position.set(1.5, 1.2, 3.5);
                camera.lookAt(0, 0, 0);

                renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('canvas'), antialias: true });
                renderer.setSize(window.innerWidth, window.innerHeight);

                controls = new THREE.OrbitControls(camera, renderer.domElement);
                controls.enableDamping = true;
                controls.minDistance = 2;
                controls.maxDistance = 8;
                controls.maxPolarAngle = Math.PI / 1.5;

                // Guitar model (fretboard only)
                guitar = new THREE.Group();

                // Neck
                const neckCanvas = document.createElement('canvas');
                neckCanvas.width = 256; neckCanvas.height = 256;
                const neckCtx = neckCanvas.getContext('2d');
                neckCtx.fillStyle = '#3C2F2F';
                neckCtx.fillRect(0, 0, 256, 256);
                for (let i = 0; i < 256; i += 20) {
                    neckCtx.fillStyle = `rgba(255, 255, 255, 0.1)`;
                    neckCtx.fillRect(0, i, 256, 2);
                }
                const neckTexture = new THREE.CanvasTexture(neckCanvas);
                const neckGeo = new THREE.BoxGeometry(0.35, 0.08, 4);
                const neckMat = new THREE.MeshPhongMaterial({ map: neckTexture });
                const neck = new THREE.Mesh(neckGeo, neckMat);
                neck.position.set(0, 0, -2);
                guitar.add(neck);

                // Headstock
                const headGeo = new THREE.BoxGeometry(0.5, 0.08, 0.6);
                const head = new THREE.Mesh(headGeo, neckMat);
                head.position.set(0, 0, -4.3);
                guitar.add(head);

                // Tuning pegs
                for (let i = -1; i <= 1; i += 2) {
                    for (let j = 0; j < 3; j++) {
                        const pegGeo = new THREE.CylinderGeometry(0.05, 0.05, 0.1, 16);
                        const pegMat = new THREE.MeshPhongMaterial({ color: 0x888888 });
                        const peg = new THREE.Mesh(pegGeo, pegMat);
                        peg.position.set(i * 0.15, 0.05, -4.3 + j * 0.15);
                        peg.rotation.z = Math.PI / 2;
                        guitar.add(peg);
                    }
                }

                // Strings
                for (let i = 0; i < 6; i++) {
                    const stringGeo = new THREE.BufferGeometry().setFromPoints([
                        new THREE.Vector3(-0.15 + i * 0.05, 0.05, -4.3),
                        new THREE.Vector3(-0.15 + i * 0.05, 0.05, 1.2)
                    ]);
                    const stringMat = new THREE.LineBasicMaterial({ color: 0xD4D4D4, linewidth: 2 });
                    const string = new THREE.Line(stringGeo, stringMat);
                    string.userData = { stringIdx: i, vibrating: false };
                    strings.push(string);
                    guitar.add(string);
                }

                // Frets
                for (let f = 0; f <= 5; f++) {
                    const fretGeo = new THREE.BoxGeometry(0.35, 0.02, 0.04);
                    const fretMat = new THREE.MeshPhongMaterial({ color: 0xC0C0C0, shininess: 100 });
                    const fret = new THREE.Mesh(fretGeo, fretMat);
                    fret.position.set(0, 0.05, -2 + f * 0.6);
                    fret.userData = { fretIdx: f };
                    frets.push(fret);
                    guitar.add(fret);
                }

                // Note labels (using canvas sprites)
                for (let s = 0; s < 6; s++) {
                    for (let f = 0; f <= 5; f++) {
                        const freq = tuning[s] * Math.pow(2, f / 12);
                        const noteName = getNoteName(freq);
                        const canvas = document.createElement('canvas');
                        canvas.width = 64; canvas.height = 32;
                        const ctx = canvas.getContext('2d');
                        ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                        ctx.fillRect(0, 0, 64, 32);
                        ctx.fillStyle = 'white';
                        ctx.font = '16px Arial';
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText(noteName, 32, 16);
                        const texture = new THREE.CanvasTexture(canvas);
                        const spriteMat = new THREE.SpriteMaterial({ map: texture });
                        const sprite = new THREE.Sprite(spriteMat);
                        sprite.position.set(-0.15 + s * 0.05 + 0.03, 0.07, -2 + f * 0.6);
                        sprite.scale.set(0.1, 0.05, 1);
                        guitar.add(sprite);
                        noteLabels.push(sprite);
                    }
                }

                // Cursor
                const cursorGeo = new THREE.SphereGeometry(0.02, 16, 16);
                const cursorMat = new THREE.MeshBasicMaterial({ color: 0x00FF00 });
                cursor = new THREE.Mesh(cursorGeo, cursorMat);
                cursor.visible = false;
                scene.add(cursor);

                scene.add(guitar);

                // Stage
                const stageGeo = new THREE.PlaneGeometry(20, 20);
                const stageMat = new THREE.MeshBasicMaterial({ color: 0x222222 });
                const stage = new THREE.Mesh(stageGeo, stageMat);
                stage.rotation.x = -Math.PI / 2;
                stage.position.y = -1;
                scene.add(stage);

                // Lighting
                const spotLight = new THREE.SpotLight(0xffffff, 0.8, 10, Math.PI / 4);
                spotLight.position.set(0, 5, 0);
                spotLight.target = guitar;
                scene.add(spotLight);
                const rimLight = new THREE.DirectionalLight(0xaaaaaa, 0.3);
                rimLight.position.set(-5, 5, -5);
                scene.add(rimLight);
                scene.add(new THREE.AmbientLight(0x404040));

                animate();
            } catch (e) {
                console.error('Error initializing 3D scene:', e);
                alert('Failed to initialize 3D scene. Please check the console for details.');
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            if (strings.some(s => s.userData.vibrating)) {
                strings.forEach(s => {
                    if (s.userData.vibrating) {
                        const t = (Date.now() - s.userData.vibrateStart) * 0.005;
                        const amp = 0.015 * Math.exp(-t / 2);
                        s.position.y = 0.05 + Math.sin(t * 10 + s.userData.stringIdx) * amp;
                    } else {
                        s.position.y = 0.05;
                    }
                });
            }
            controls.update();
            renderer.render(scene, camera);
        }

        function highlightFret(stringIdx, fret) {
            try {
                const string = strings[stringIdx];
                string.userData.vibrating = true;
                string.userData.vibrateStart = Date.now();
                string.material.color.set(0xFFFF00);
                setTimeout(() => {
                    string.userData.vibrating = false;
                    string.material.color.set(0xD4D4D4);
                }, 1500);
                if (fret > 0) {
                    frets[fret].material.emissive.set(0xFFFF00);
                    setTimeout(() => frets[fret].material.emissive.set(0x000000), 1500);
                }
            } catch (e) {
                console.error('Error highlighting fret:', e);
            }
        }

        function strum(chord) {
            try {
                let hasPlayableNotes = false;
                for (let s = 0; s < 6; s++) {
                    const f = chord[s];
                    if (f >= 0) {
                        hasPlayableNotes = true;
                        const freq = tuning[s] * Math.pow(2, f / 12);
                        playNote(freq, 2);
                        highlightFret(s, f);
                    }
                }
                if (!hasPlayableNotes) {
                    alert('No playable notes selected! Set frets or select a chord.');
                }
            } catch (e) {
                console.error('Error strumming chord:', e);
            }
        }

        function strumMarkedNotes() {
            try {
                if (markedNotes.length === 0) {
                    alert('No notes marked to strum!');
                    return;
                }
                markedNotes.forEach((note, i) => {
                    setTimeout(() => {
                        const freq = tuning[note.stringIdx] * Math.pow(2, note.fret / 12);
                        playNote(freq, 1);
                        highlightFret(note.stringIdx, note.fret);
                    }, i * 100);
                });
            } catch (e) {
                console.error('Error strumming marked notes:', e);
            }
        }

        function strumRoll(stringIndices) {
            try {
                stringIndices.forEach((stringIdx, i) => {
                    const f = currentFrets[stringIdx];
                    if (f >= 0) {
                        setTimeout(() => {
                            const freq = tuning[stringIdx] * Math.pow(2, f / 12);
                            playNote(freq, 1);
                            highlightFret(stringIdx, f);
                        }, i * 100);
                    }
                });
            } catch (e) {
                console.error('Error in strum roll:', e);
            }
        }

        // Fretboard UI update
        function updateFretboardUI() {
            try {
                document.querySelectorAll('#strings button').forEach(btn => {
                    const s = parseInt(btn.dataset.string);
                    const f = parseInt(btn.dataset.fret);
                    btn.classList.toggle('bg-blue-500', currentFrets[s] === f && f === 0);
                    btn.classList.toggle('bg-yellow-500', currentFrets[s] === f && f > 0);
                    btn.classList.toggle('text-black', currentFrets[s] === f);
                    btn.classList.toggle('relative', markedNotes.some(note => note.stringIdx === s && note.fret === f) || (currentChord && (chords[currentChord] || lockedChords[currentChord]) && (chords[currentChord] || lockedChords[currentChord])[s] === f));
                    if (markedNotes.some(note => note.stringIdx === s && note.fret === f)) {
                        if (!btn.querySelector('.note-marker')) {
                            const marker = document.createElement('div');
                            marker.className = 'note-marker';
                            marker.style.left = '50%';
                            marker.style.top = '50%';
                            marker.style.transform = 'translate(-50%, -50%)';
                            btn.appendChild(marker);
                        }
                    } else {
                        const marker = btn.querySelector('.note-marker');
                        if (marker) marker.remove();
                    }
                    if (currentChord && (chords[currentChord] || lockedChords[currentChord]) && (chords[currentChord] || lockedChords[currentChord])[s] === f) {
                        if (!btn.querySelector('.chord-marker')) {
                            const marker = document.createElement('div');
                            marker.className = 'chord-marker';
                            marker.style.left = '50%';
                            marker.style.top = '50%';
                            marker.style.transform = 'translate(-50%, -50%)';
                            btn.appendChild(marker);
                        }
                    } else {
                        const marker = btn.querySelector('.chord-marker');
                        if (marker) marker.remove();
                    }
                });
            } catch (e) {
                console.error('Error updating fretboard UI:', e);
            }
        }

        // Update 3D note and chord markers
        function update3DNoteMarkers() {
            try {
                noteMarkers.forEach(marker => scene.remove(marker));
                noteMarkers = [];
                markedNotes.forEach(note => {
                    const markerGeo = new THREE.SphereGeometry(0.04, 16, 16);
                    const markerMat = new THREE.MeshBasicMaterial({ color: 0xFF5555, transparent: true, opacity: 0.8 });
                    const marker = new THREE.Mesh(markerGeo, markerMat);
                    marker.position.set(-0.15 + note.stringIdx * 0.05, 0.06, -2 + note.fret * 0.6);
                    scene.add(marker);
                    noteMarkers.push(marker);
                });
                chordMarkers.forEach(marker => scene.remove(marker));
                chordMarkers = [];
                if (currentChord && (chords[currentChord] || lockedChords[currentChord])) {
                    (chords[currentChord] || lockedChords[currentChord]).forEach((fret, stringIdx) => {
                        if (fret >= 0) {
                            const markerGeo = new THREE.SphereGeometry(0.04, 16, 16);
                            const markerMat = new THREE.MeshBasicMaterial({ color: 0x55FF55, transparent: true, opacity: 0.8 });
                            const marker = new THREE.Mesh(markerGeo, markerMat);
                            marker.position.set(-0.15 + stringIdx * 0.05, 0.06, -2 + fret * 0.6);
                            scene.add(marker);
                            chordMarkers.push(marker);
                        }
                    });
                }
            } catch (e) {
                console.error('Error updating 3D note markers:', e);
            }
        }

        // Raycasting
        let raycaster = new THREE.Raycaster();
        let mouse = new THREE.Vector2();
        let lastStrummedString = -1;
        function onMouseClick(event) {
            if (!isFretboardMode) return;
            try {
                mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
                mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
                raycaster.setFromCamera(mouse, camera);
                const intersects = raycaster.intersectObjects([...strings, ...frets]);
                if (intersects.length > 0) {
                    const obj = intersects[0].object;
                    if (obj.userData.stringIdx !== undefined) {
                        const stringIdx = obj.userData.stringIdx;
                        const freq = tuning[stringIdx];
                        currentFrets[stringIdx] = 0;
                        playNote(freq, 1);
                        highlightFret(stringIdx, 0);
                        markedNotes.push({ stringIdx, fret: 0 });
                        updateFretboardUI();
                        update3DNoteMarkers();
                    } else if (obj.userData.fretIdx !== undefined) {
                        const stringIntersects = raycaster.intersectObjects(strings);
                        if (stringIntersects.length > 0) {
                            const stringIdx = stringIntersects[0].object.userData.stringIdx;
                            const fretIdx = obj.userData.fretIdx;
                            const freq = tuning[stringIdx] * Math.pow(2, fretIdx / 12);
                            currentFrets[stringIdx] = fretIdx;
                            playNote(freq, 1);
                            highlightFret(stringIdx, fretIdx);
                            markedNotes.push({ stringIdx, fret: fretIdx });
                            updateFretboardUI();
                            update3DNoteMarkers();
                        }
                    }
                }
            } catch (e) {
                console.error('Error in mouse click handler:', e);
            }
        }

        function onMouseMove(event) {
            try {
                mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
                mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
                const fretPopup = document.getElementById('fret-popup');
                fretPopup.style.display = 'none';
                if (!isFretboardMode) {
                    cursor.visible = false;
                    return;
                }
                raycaster.setFromCamera(mouse, camera);
                const intersects = raycaster.intersectObjects([...strings, ...frets]);
                strings.forEach(s => s.material.color.set(0xD4D4D4));
                frets.forEach(f => f.material.emissive.set(0x000000));
                cursor.visible = false;
                if (intersects.length > 0) {
                    const obj = intersects[0].object;
                    if (obj.userData.stringIdx !== undefined) {
                        obj.material.color.set(0xFFFF00);
                        cursor.visible = true;
                        cursor.position.set(-0.15 + obj.userData.stringIdx * 0.05, 0.06, -2);
                        fretPopup.style.display = 'block';
                        fretPopup.style.left = `${event.clientX + 10}px`;
                        fretPopup.style.top = `${event.clientY + 10}px`;
                        const freq = tuning[obj.userData.stringIdx];
                        fretPopup.textContent = `String ${obj.userData.stringIdx + 1}, Fret 0, ${getNoteName(freq)}`;
                        if (obj.userData.stringIdx !== lastStrummedString) {
                            lastStrummedString = obj.userData.stringIdx;
                            strumRoll([obj.userData.stringIdx]);
                        }
                    } else if (obj.userData.fretIdx !== undefined) {
                        obj.material.emissive.set(0xFFFF00);
                        const stringIntersects = raycaster.intersectObjects(strings);
                        if (stringIntersects.length > 0) {
                            const stringIdx = stringIntersects[0].object.userData.stringIdx;
                            const fretIdx = obj.userData.fretIdx;
                            cursor.visible = true;
                            cursor.position.set(-0.15 + stringIdx * 0.05, 0.06, -2 + fretIdx * 0.6);
                            const freq = tuning[stringIdx] * Math.pow(2, fretIdx / 12);
                            fretPopup.style.display = 'block';
                            fretPopup.style.left = `${event.clientX + 10}px`;
                            fretPopup.style.top = `${event.clientY + 10}px`;
                            fretPopup.textContent = `String ${stringIdx + 1}, Fret ${fretIdx}, ${getNoteName(freq)}`;
                        }
                    }
                } else {
                    lastStrummedString = -1;
                }
            } catch (e) {
                console.error('Error in mouse move handler:', e);
            }
        }

        // UI Interactions
        document.addEventListener('DOMContentLoaded', () => {
            try {
                document.getElementById('loading').style.display = 'flex';
                initAudio();
                init3D();
                setTimeout(() => document.getElementById('loading').style.display = 'none', 500);

                document.getElementById('canvas').addEventListener('click', onMouseClick);
                document.getElementById('canvas').addEventListener('mousemove', onMouseMove);

                // Fretboard UI
                const stringsDiv = document.getElementById('strings');
                for (let s = 0; s < 6; s++) {
                    const stringDiv = document.createElement('div');
                    stringDiv.className = 'flex';
                    for (let f = 0; f <= 5; f++) {
                        const fretBtn = document.createElement('button');
                        fretBtn.textContent = f === 0 ? 'O' : f;
                        fretBtn.className = 'w-12 h-8 border border-gray-500 bg-gray-700 text-white hover:bg-gray-600 relative';
                        fretBtn.dataset.string = s;
                        fretBtn.dataset.fret = f;
                        fretBtn.setAttribute('aria-label', `String ${s + 1}, Fret ${f}`);
                        fretBtn.addEventListener('click', (e) => {
                            try {
                                const s = parseInt(e.target.dataset.string);
                                const f = parseInt(e.target.dataset.fret);
                                currentFrets[s] = f;
                                const freq = tuning[s] * Math.pow(2, f / 12);
                                playNote(freq, 1);
                                highlightFret(s, f);
                                markedNotes.push({ stringIdx: s, fret: f });
                                updateFretboardUI();
                                update3DNoteMarkers();
                            } catch (e) {
                                console.error('Error in fretboard click:', e);
                            }
                        });
                        stringDiv.appendChild(fretBtn);
                    }
                    stringsDiv.appendChild(stringDiv);
                }

                // Fretboard grid
                const grid = document.createElement('div');
                grid.className = 'fretboard-grid';
                grid.style.display = 'grid';
                grid.style.gridTemplateColumns = 'repeat(6, 1fr)';
                grid.style.gridTemplateRows = 'repeat(6, 1fr)';
                for (let i = 0; i < 36; i++) {
                    grid.appendChild(document.createElement('div'));
                }
                stringsDiv.appendChild(grid);

                // Toggle mouse mode
                document.getElementById('toggle-mouse').addEventListener('click', () => {
                    try {
                        isFretboardMode = !isFretboardMode;
                        controls.enabled = !isFretboardMode;
                        document.getElementById('toggle-mouse').textContent = isFretboardMode ? 'Fretboard Mode' : 'Camera Mode';
                        document.getElementById('mouse-mode').textContent = isFretboardMode ? 'Play/Mark Notes' : 'Rotate/Zoom';
                        cursor.visible = isFretboardMode;
                    } catch (e) {
                        console.error('Error toggling mouse mode:', e);
                    }
                });

                // Strum
                document.getElementById('strum').addEventListener('click', () => {
                    try {
                        if (currentChord && (chords[currentChord] || lockedChords[currentChord])) {
                            strum(chords[currentChord] || lockedChords[currentChord]);
                        } else {
                            strum(currentFrets);
                        }
                    } catch (e) {
                        console.error('Error in strum:', e);
                    }
                });

                // Strum marked notes
                document.getElementById('strum-marked').addEventListener('click', () => {
                    try {
                        if (markedNotes.length === 0) {
                            alert('No notes marked to strum!');
                            return;
                        }
                        strumMarkedNotes();
                    } catch (e) {
                        console.error('Error strumming marked notes:', e);
                    }
                });

                // Populate chord buttons and picker
                function updateChordUI() {
                    try {
                        const chordButtons = document.getElementById('chord-buttons');
                        chordButtons.innerHTML = '';
                        const chordPicker = document.getElementById('chord-picker');
                        chordPicker.innerHTML = '<option value="">Select Chord</option>';
                        Object.keys(chords).forEach(name => {
                            const btn = document.createElement('button');
                            btn.className = 'chord-btn bg-red-600 text-white px-4 py-2 rounded-lg hover:bg-red-700 draggable';
                            btn.dataset.chord = name;
                            btn.textContent = name;
                            btn.dataset.tooltip = `Play ${name}`;
                            btn.setAttribute('aria-label', `Play chord ${name}`);
                            btn.addEventListener('click', (e) => {
                                currentChord = name;
                                currentFrets.forEach((_, i) => currentFrets[i] = chords[name][i]);
                                strum(chords[name]);
                                e.target.classList.add('bg-red-800');
                                setTimeout(() => e.target.classList.remove('bg-red-800'), 500);
                                updateFretboardUI();
                                update3DNoteMarkers();
                            });
                            chordButtons.appendChild(btn);
                            const option = document.createElement('option');
                            option.value = name;
                            option.textContent = name;
                            chordPicker.appendChild(option);
                        });
                        Object.keys(lockedChords).forEach(name => {
                            if (!chords[name]) {
                                const option = document.createElement('option');
                                option.value = name;
                                option.textContent = name;
                                chordPicker.appendChild(option);
                            }
                        });
                        makeButtonsDraggable();
                    } catch (e) {
                        console.error('Error updating chord UI:', e);
                    }
                }
                updateChordUI();

                // Chord picker
                document.getElementById('chord-picker').addEventListener('change', (e) => {
                    try {
                        const name = e.target.value;
                        if (name && (chords[name] || lockedChords[name])) {
                            currentChord = name;
                            currentFrets.forEach((_, i) => currentFrets[i] = (chords[name] || lockedChords[name])[i]);
                            updateFretboardUI();
                            update3DNoteMarkers();
                        }
                    } catch (e) {
                        console.error('Error in chord picker:', e);
                    }
                });

                // Piano keys
                const pianoDiv = document.getElementById('piano-keys');
                const pianoNotes = ['C4', 'D4', 'E4', 'F4', 'G4', 'A4', 'B4'];
                pianoNotes.forEach((note, i) => {
                    const key = document.createElement('div');
                    key.className = `w-16 h-10 border border-black ${i % 2 ? 'bg-black text-white' : 'bg-white text-black'} cursor-pointer flex items-center justify-center`;
                    key.textContent = note;
                    key.setAttribute('aria-label', `Piano key ${note}`);
                    key.addEventListener('click', () => {
                        try {
                            const freq = 261.63 * Math.pow(2, i / 12);
                            playNote(freq, 1);
                        } catch (e) {
                            console.error('Error in piano key click:', e);
                        }
                    });
                    pianoDiv.appendChild(key);
                });

                // Lock chord
                document.getElementById('lock-chord').addEventListener('click', () => {
                    try {
                        const name = prompt('Enter name for locked chord:');
                        if (name && !lockedChords[name]) {
                            lockedChords[name] = [...currentFrets];
                            const option = document.createElement('option');
                            option.value = name;
                            option.textContent = name;
                            document.getElementById('recall-chord').appendChild(option);
                            updateChordUI();
                        } else if (name) {
                            alert('Chord name already exists!');
                        }
                    } catch (e) {
                        console.error('Error locking chord:', e);
                    }
                });

                // Recall chord
                document.getElementById('recall-chord').addEventListener('change', (e) => {
                    try {
                        const name = e.target.value;
                        if (name && (chords[name] || lockedChords[name])) {
                            currentChord = name;
                            currentFrets.forEach((_, i) => currentFrets[i] = (chords[name] || lockedChords[name])[i]);
                            updateFretboardUI();
                            update3DNoteMarkers();
                        }
                    } catch (e) {
                        console.error('Error recalling chord:', e);
                    }
                });

                // Replay marked notes
                document.getElementById('replay-notes').addEventListener('click', () => {
                    try {
                        markedNotes.forEach((note, i) => {
                            setTimeout(() => {
                                const freq = tuning[note.stringIdx] * Math.pow(2, note.fret / 12);
                                playNote(freq, 1);
                                highlightFret(note.stringIdx, note.fret);
                            }, i * 200);
                        });
                    } catch (e) {
                        console.error('Error replaying notes:', e);
                    }
                });

                // Clear marked notes
                document.getElementById('clear-notes').addEventListener('click', () => {
                    try {
                        markedNotes.length = 0;
                        updateFretboardUI();
                        update3DNoteMarkers();
                    } catch (e) {
                        console.error('Error clearing notes:', e);
                    }
                });

                // Recording
                let recordings = [];
                let currentRecording = [];
                let isRecording = false;
                document.getElementById('record').addEventListener('change', (e) => {
                    try {
                        isRecording = e.target.checked;
                        if (isRecording) {
                            currentRecording = [];
                        } else if (currentRecording.length > 0) {
                            recordings.push(currentRecording);
                            const btn = document.createElement('button');
                            btn.textContent = `Play #${recordings.length}`;
                            btn.className = 'bg-green-500 text-white px-4 py-2 rounded-lg hover:bg-green-600';
                            btn.setAttribute('aria-label', `Play recording ${recordings.length}`);
                            btn.addEventListener('click', () => {
                                const start = recordings[recordings.length - 1][0].time;
                                recordings[recordings.length - 1].forEach(note => {
                                    setTimeout(() => playNote(note.freq, note.dur), note.time - start);
                                });
                            });
                            document.getElementById('playback-buttons').appendChild(btn);
                        }
                    } catch (e) {
                        console.error('Error in recording:', e);
                    }
                });

                const originalPlay = playNote;
                playNote = function(freq, dur) {
                    const note = originalPlay(freq, dur);
                    if (isRecording && note) {
                        currentRecording.push(note);
                    }
                };

                // Save custom chord
                document.getElementById('save-chord').addEventListener('click', () => {
                    try {
                        const name = prompt('Enter chord name:');
                        if (name && !chords[name] && !lockedChords[name]) {
                            chords[name] = [...currentFrets];
                            updateChordUI();
                        } else if (name) {
                            alert('Chord name already exists!');
                        }
                    } catch (e) {
                        console.error('Error saving chord:', e);
                    }
                });

                // Save all
                document.getElementById('save-all').addEventListener('click', () => {
                    document.getElementById('loading').style.display = 'flex';
                    try {
                        const data = { chords, lockedChords, recordings, markedNotes };
                        const blob = new Blob([JSON.stringify(data)], { type: 'application/json' });
                        const url = URL.createObjectURL(blob);
                        const a = document.createElement('a');
                        a.href = url;
                        a.download = 'guitar-data.json';
                        a.click();
                        URL.revokeObjectURL(url);
                    } catch (e) {
                        console.error('Error saving data:', e);
                        alert('Failed to save data.');
                    } finally {
                        document.getElementById('loading').style.display = 'none';
                    }
                });

                // Load all
                document.getElementById('load-all').addEventListener('change', (e) => {
                    const file = e.target.files[0];
                    if (file) {
                        document.getElementById('loading').style.display = 'flex';
                        const reader = new FileReader();
                        reader.onload = (ev) => {
                            try {
                                const data = JSON.parse(ev.target.result);
                                Object.assign(chords, data.chords);
                                Object.assign(lockedChords, data.lockedChords);
                                recordings = data.recordings || [];
                                markedNotes.length = 0;
                                markedNotes.push(...(data.markedNotes || []));
                                updateChordUI();
                                const recallSelect = document.getElementById('recall-chord');
                                recallSelect.innerHTML = '<option value="">Recall Locked Chord</option>';
                                Object.keys(lockedChords).forEach(name => {
                                    const option = document.createElement('option');
                                    option.value = name;
                                    option.textContent = name;
                                    recallSelect.appendChild(option);
                                });
                                document.getElementById('playback-buttons').innerHTML = '';
                                recordings.forEach((rec, i) => {
                                    const btn = document.createElement('button');
                                    btn.textContent = `Play #${i + 1}`;
                                    btn.className = 'bg-green-500 text-white px-4 py-2 rounded-lg hover:bg-green-600';
                                    btn.setAttribute('aria-label', `Play recording ${i + 1}`);
                                    btn.addEventListener('click', () => {
                                        const start = rec[0].time;
                                        rec.forEach(note => {
                                            setTimeout(() => playNote(note.freq, note.dur), note.time - start);
                                        });
                                    });
                                    document.getElementById('playback-buttons').appendChild(btn);
                                });
                                updateFretboardUI();
                                update3DNoteMarkers();
                            } catch (e) {
                                console.error('Error loading data:', e);
                                alert('Failed to load data. Ensure the file is valid JSON.');
                            } finally {
                                document.getElementById('loading').style.display = 'none';
                            }
                        };
                        reader.readAsText(file);
                    }
                });

                // Popup for editing chords
                document.getElementById('edit-chords').addEventListener('click', () => {
                    try {
                        const popup = document.getElementById('chord-popup');
                        const chordList = document.getElementById('chord-list');
                        chordList.innerHTML = '';
                        Object.keys(chords).forEach(name => {
                            const div = document.createElement('div');
                            div.className = 'flex justify-between items-center';
                            div.innerHTML = `
                                <span>${name}</span>
                                <div>
                                    <button class="edit-chord bg-blue-500 text-white px-2 py-1 rounded hover:bg-blue-600" data-chord="${name}" aria-label="Edit chord ${name}">Edit</button>
                                    <button class="delete-chord bg-red-500 text-white px-2 py-1 rounded hover:bg-red-600" data-chord="${name}" aria-label="Delete chord ${name}">Delete</button>
                                </div>
                            `;
                            chordList.appendChild(div);
                        });
                        popup.style.display = 'flex';
                    } catch (e) {
                        console.error('Error opening chord editor:', e);
                    }
                });

                document.getElementById('close-popup').addEventListener('click', () => {
                    document.getElementById('chord-popup').style.display = 'none';
                });

                document.getElementById('chord-list').addEventListener('click', (e) => {
                    try {
                        if (e.target.classList.contains('edit-chord')) {
                            const name = e.target.dataset.chord;
                            const newName = prompt('Enter new chord name:', name);
                            if (newName && newName !== name && !chords[newName] && !lockedChords[newName]) {
                                chords[newName] = chords[name];
                                delete chords[name];
                                updateChordUI();
                            } else if (newName) {
                                alert('Chord name already exists!');
                            }
                        } else if (e.target.classList.contains('delete-chord')) {
                            const name = e.target.dataset.chord;
                            if (confirm(`Delete chord ${name}?`)) {
                                delete chords[name];
                                updateChordUI();
                            }
                        }
                    } catch (e) {
                        console.error('Error in chord editor:', e);
                    }
                });

                // Drag-and-drop chord buttons
                function makeButtonsDraggable() {
                    try {
                        const buttons = document.querySelectorAll('.chord-btn');
                        buttons.forEach(btn => {
                            btn.draggable = true;
                            btn.addEventListener('dragstart', (e) => {
                                e.dataTransfer.setData('text/plain', e.target.dataset.chord);
                            });
                        });
                        const chordButtons = document.getElementById('chord-buttons');
                        chordButtons.addEventListener('dragover', (e) => {
                            e.preventDefault();
                        });
                        chordButtons.addEventListener('drop', (e) => {
                            e.preventDefault();
                            const chordName = e.dataTransfer.getData('text/plain');
                            const target = e.target.closest('.chord-btn');
                            if (target && target.dataset.chord !== chordName) {
                                const buttons = Array.from(chordButtons.children);
                                const fromIndex = buttons.findIndex(btn => btn.dataset.chord === chordName);
                                const toIndex = buttons.findIndex(btn => btn.dataset.chord === target.dataset.chord);
                                if (fromIndex < toIndex) {
                                    chordButtons.insertBefore(buttons[fromIndex], buttons[toIndex].nextSibling);
                                } else {
                                    chordButtons.insertBefore(buttons[fromIndex], buttons[toIndex]);
                                }
                            }
                        });
                    } catch (e) {
                        console.error('Error setting up drag-and-drop:', e);
                    }
                }

                // Keyboard navigation
                document.addEventListener('keydown', (e) => {
                    try {
                        if (e.code === 'Space') {
                            e.preventDefault();
                            if (currentChord && (chords[currentChord] || lockedChords[currentChord])) {
                                strum(chords[currentChord] || lockedChords[currentChord]);
                            } else {
                                strum(currentFrets);
                            }
                        } else if (e.code === 'Escape') {
                            currentChord = null;
                            currentFrets.fill(0);
                            updateFretboardUI();
                            update3DNoteMarkers();
                        } else if (e.code === 'Tab' && !e.shiftKey) {
                            e.preventDefault();
                            const focuses = document.querySelectorAll('button, select, input');
                            const index = Array.from(focuses).indexOf(document.activeElement);
                            focuses[(index + 1) % focuses.length].focus();
                        }
                    } catch (e) {
                        console.error('Error in keyboard handler:', e);
                    }
                });

                // Resize
                window.addEventListener('resize', () => {
                    try {
                        camera.aspect = window.innerWidth / window.innerHeight;
                        camera.updateProjectionMatrix();
                        renderer.setSize(window.innerWidth, window.innerHeight);
                    } catch (e) {
                        console.error('Error in resize handler:', e);
                    }
                });
            } catch (e) {
                console.error('Error in DOMContentLoaded:', e);
                document.getElementById('loading').style.display = 'none';
                alert('Failed to initialize application. Please check the console for details.');
            }
        });
    </script>
</body>
</html>